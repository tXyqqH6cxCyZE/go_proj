// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package app

import (
	//"flag"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"os/signal"
	"runtime"
	"syscall"
	"time"

	"micode.be.xiaomi.com/systech/asset/xrsmonitor"
	"micode.be.xiaomi.com/systech/asset/xstatsd"
	"micode.be.xiaomi.com/systech/base/xutil"
	"micode.be.xiaomi.com/systech/soa/ratelimit"
	"micode.be.xiaomi.com/systech/soa/thrift"
	"micode.be.xiaomi.com/systech/soa/tracing"
	"micode.be.xiaomi.com/systech/soa/xenviron"
	"micode.be.xiaomi.com/systech/soa/xlog"
	"os/user"
)

var (
	server         *thrift.TSimpleServer
	serverStop     = false
	isThriftServer = false
	needRestart    = false
	//DefReadTimeout = 60 * time.Second
	DefReadTimeout = 0 * time.Second
	env            = ""
)

func runServer(transportFactory thrift.TTransportFactory,
	protocolFactory thrift.TProtocolFactory,
	addr string, processor thrift.TProcessor) error {

	var transport thrift.TServerTransport
	transport, err := thrift.NewTServerSocketTimeout(addr, DefReadTimeout)
	if err != nil {
		return err
	}

	server = thrift.NewTSimpleServer4(processor, transport, transportFactory, protocolFactory)
	return server.Serve()
}

func initEnviron() (env, cluster string, err error) {
	environ := xenviron.NewXEnviron()
	err = environ.Open(Config().ConfigAddr,
		Config().EnvironNode)
	if err != nil {
		return
	}

	env = environ.Get()
	cluster = environ.GetCluster()
	environ.Close()
	return
}

func GracefulStop() {

	xlog.Warn("admin stop service:%s, exiting", Config().ServiceName)
	//重启超时，强制退出
	go forceStop()
	if server != nil {
		server.Stop()
	}
}

func reopen() {
	xlog.ReOpen()
}

func InitApp(environ string) (err error) {

	err = initRpc(environ)
	if err != nil {
		return
	}

	return globalDataMgr.Init()
}

func CatchSignal(signalChan chan os.Signal) {
	for {
		if serverStop {
			return
		}
		select {
		case sig := <-signalChan:
			switch sig {
			case syscall.SIGUSR1:
				GracefulStop()
			case syscall.SIGUSR2:
				reopen()
			case syscall.SIGQUIT:
				GracefulStop()
			case syscall.SIGHUP:
				GracefulStop()
				//needRestart = true
			}
		}
	}
}

func InitSignal() {
	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, syscall.SIGUSR1, syscall.SIGUSR2, syscall.SIGQUIT, syscall.SIGHUP)
	go CatchSignal(signalChan)
}

func writePid(path string) {

	pid := os.Getpid()
	filename := fmt.Sprintf("%s/pid", path)

	ioutil.WriteFile(filename, []byte(fmt.Sprintf("%d", pid)), 0755)
}

func InitFramework(path, filename string) (err error) {

	runtime.GOMAXPROCS(runtime.NumCPU())
	g_pluginMgr.OnStartup()

	InitSignal()
	autoGenerate := false

	g_pluginMgr.OnBeforeLoadConfig()
	err = InitBaseConf(path, filename)
	if err != nil {
		fmt.Println("initConfig failed, err:", err)
		return
	}

	if autoGenerate {
		err = Generate(path, filename)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println("generate code from config succ")
		os.Exit(0)
	}

	environ, cluster, err := initEnviron()
	if err != nil {
		fmt.Printf("InitEnviron failed, err:%v\n", err)
		return
	}
	env = environ

	err = InitAppConf(path, filename, environ)
	if err != nil {
		fmt.Println("initConfig failed, err:", err)
		return
	}

	err = xlog.InitLogger(Config().ServiceName,
		Config().LogPath,
		Config().ServiceName,
		Config().LogLevel,
		Config().Output,
		Config().DoSplit,
	)
	if err != nil {
		fmt.Printf("InitLogger failed, err:%v\n", err)
		return
	}
	thrift.SetPrintGlobalFlag(Config().LogGlobalFlag)
	thrift.SetPrintApiFlag(Config().ApiIOLog)

	err = tracing.InitGlobalTracerWithParams(Config().GroupName, Config().ServiceName,
		Config().TracingEnabled, Config().TracingSamplerType, Config().TracingSamplerParam)
	if err != nil {
		xlog.Fatal("InitGlobalTracer failed, err: %v", err)
		return
	}
	xlog.Notice("InitGlobalTracer success")

	err = ratelimit.Init(Config().RateLimitEnabled, Config().RateLimitConf)
	if err != nil {
		xlog.Fatal("InitRateLimiter failed, err: %v", err)
		return
	}
	xlog.Notice("InitRateLimiter success")

	RunManager(Config().AdminPort)

	xstatsd.Init(Config().ConfigAddr, Config().GroupName, Config().ServiceName, environ)

	xrsmonitor.Init()

	thrift.InitStat(Config().StatInterval,
		Config().GroupName,
		Config().ServiceName,
		Config().StatAddr,
	)
	err = thrift.InitAuthWithEnable(Config().ConfigAddr,
		Config().RootNode,
		Config().GroupName,
		Config().ServiceName,
		environ,
		Config().EnableIPAuth,
		Config().EnableMethodAuth,
	)
	if err != nil {
		xlog.Fatal("init auth failed, err:%v", err)
		return
	}

	err = InitApp(environ)
	if err != nil {
		xlog.Fatal("InitApp failed, err:%v", err)
		return
	}

	err = runWithTimeout(func() error {
		g_pluginMgr.OnAfterLoadConfig()
		return nil
	}, Config().AfterLoadConfigTimeout)
	if err != nil {
		xlog.Fatal("OnAfterLoadconfig hook failed, err: %v", err)
		return
	}

	appConfigMgr.plugin = g_pluginMgr

	writePid(path)

	err = InitRegister(environ, cluster)
	if err != nil {
		xlog.Fatal("register etced failed, err:%v", err)
		return
	}

	return
}

func restart() {

	path := os.Args[0]
	var args []string

	if len(os.Args) > 1 {
		for _, arg := range os.Args[1:] {
			args = append(args, arg)
		}
	}

	cmd := exec.Command(path, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	err := cmd.Start()
	if err != nil {
		xlog.Fatal("restart %v failed, error: %v", path, err)
	}
}

func checkUser() bool {
	usr, err := user.Current()
	if err != nil {
		xlog.Fatal("get current user failed: %v", err)
		return false
	}
	if usr.Username == "root" {
		xlog.Fatal("current user is root which is not allowed to run service.")
		return false
	}
	return true
}

func Run(processor thrift.TProcessor, plugin XPlugin) (err error) {

	if !checkUser() {
		return
	}
	isThriftServer = true
	RegisterPlugin(plugin)
	path, err := xutil.GetExecPath()
	if err != nil {
		fmt.Println("GetExecPath failed, err:", err)
		return
	}

	confPath := path + "/../config/"
	err = InitFramework(confPath, "scm_config.ini")
	if err != nil {
		xlog.Fatal("init framework failed, err:%v", err)
		fmt.Printf("init framework failed, err:%v\n", err)
		return
	}

	addr := fmt.Sprintf("0.0.0.0:%d", Config().ListenPort)
	protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()

	var transportFactory thrift.TTransportFactory
	transportFactory = thrift.NewTBufferedTransportFactory(8192)
	transportFactory = thrift.NewXmHeaderTransportFactory(transportFactory)

	err = runServer(transportFactory, protocolFactory, addr, processor)
	if err != nil {
		xlog.Fatal("run server failed, err:%v", err)
		fmt.Printf("run server failed, err:%v\n", err)
		return
	}

	serverStop = true
	//if needRestart {
	//	restart()
	//}
	return
}

func runWithTimeout(f func() error, seconds int) error {
	ch := make(chan error, 1)
	defer close(ch)
	go func() {
		err := f()
		if err != nil {
			ch <- err
		} else {
			ch <- nil
		}
	}()

	select {
	case err := <-ch:
		return err
	case <-time.After(time.Duration(seconds) * time.Second):
		return errors.New("operation timeout")
	}
}

func GetEnv() string {
	return env
}

func IsTest() bool {
	return env == xenviron.XEnvironTestName
}

func IsPrev() bool {
	return env == xenviron.XEnvironPrevName
}

func IsOnline() bool {
	return env == xenviron.XEnvironOnlineName
}
