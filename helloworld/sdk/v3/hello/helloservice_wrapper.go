// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package hello

import (
	"fmt"
	"micode.be.xiaomi.com/systech/asset/xstatsd"
	"micode.be.xiaomi.com/systech/base/xtype_convert"
	"micode.be.xiaomi.com/systech/base/xutil"
	"micode.be.xiaomi.com/systech/soa/thrift"
	"micode.be.xiaomi.com/systech/soa/xrpc"
	"micode.be.xiaomi.com/systech/soa/xrpc/xconfig"
	"micode.be.xiaomi.com/systech/soa/xrpc/xpool"
	"os"
	"path"
	"strings"
	tm "time"
)

type HelloServiceClientWrapper struct {
	RpcCallHelper
	invokeId string
	myIp     string
}

var modeFlag bool = false
var mockService HelloServiceInf

func InitHelloServiceMock(serviceMockObj HelloServiceInf) {
	modeFlag = true
	mockService = serviceMockObj
}

var logger *FileLog

type FileLog struct {
	file *os.File
}

func InitFileLog(folder string, filename string) error {
	if logger == nil {
		logger = &FileLog{}
		os.MkdirAll(folder, 0755)
		pth := path.Join(folder, filename)
		file, err := os.OpenFile(pth,
			os.O_CREATE|os.O_APPEND|os.O_WRONLY,
			0644,
		)

		if err != nil {
			logger.file = nil
			return xutil.NewError("open %s failed, err:%v", pth, err)
		} else {
			logger.file = file
		}
	}
	return nil
}

func (p *FileLog) write(s string) {
	if p.file != nil {
		p.file.WriteString(s)
	}
}

func NewHelloServiceClientWrapper(serviceName string, rpc *xrpc.XRpc,
	ctx *thrift.XContext, invokeId ...string) HelloServiceInf {
	if ctx == nil {
		ctx = thrift.NewXContext("xxxx", 0, 0)
	}

	wrapper := &HelloServiceClientWrapper{}
	wrapper.serviceName = serviceName
	wrapper.rpc = rpc
	wrapper.ctx = ctx
	wrapper.methodTimeout = make(map[string]uint32)
	if invokeId != nil && len(invokeId) > 0 {
		wrapper.invokeId = invokeId[0]
		wrapper.myIp, _ = xutil.GetLocalIP()
	}
	return wrapper
}

func NewHelloServiceClientWrapper2(serviceName string, ctx *thrift.XContext, invokeId ...string) HelloServiceInf {
	if modeFlag == true {
		return mockService
	} else {
		if ctx == nil {
			ctx = thrift.NewXContext("xxxx", 0, 0)
		}

		wrapper := &HelloServiceClientWrapper{}
		wrapper.serviceName = serviceName
		wrapper.rpc = xrpc.GetInstance()
		wrapper.ctx = ctx
		wrapper.methodTimeout = make(map[string]uint32)
		if invokeId != nil && len(invokeId) > 0 {
			wrapper.invokeId = invokeId[0]
			wrapper.myIp, _ = xutil.GetLocalIP()
		}
		return wrapper
	}
}

// Parameters:
//  - Name
func (p *HelloServiceClientWrapper) HelloWorld(name string) (r *Result_, errRet error) {
	statMap := make(map[string]interface{})
	ctx := thrift.NewXContext(p.rpc.GetServiceName(), p.ctx.GetLogId(), p.ctx.GetRpcId())
	statMap["rpc_id"] = ctx.GetRpcId()
	callFailed := 1
	defer func() {
		cost := ctx.EndTime("HelloWorld")
		statMap["cost"] = cost

		p.ctx.Set("HelloWorld", statMap)
		xstatsd.PrivateCount(fmt.Sprintf("backend.service.%s.total", p.serviceName), 1)
		xstatsd.PrivateCount(fmt.Sprintf("backend.service.%s.failed", p.serviceName), int64(callFailed))
		xstatsd.PrivateTiming(fmt.Sprintf("backend.service.%s.timing", p.serviceName), int64(cost))

		xstatsd.PrivateCount(fmt.Sprintf("backend.service.%s.method.%s.total", p.serviceName, "HelloWorld"), 1)
		xstatsd.PrivateCount(fmt.Sprintf("backend.service.%s.method.%s.failed", p.serviceName, "HelloWorld"), int64(callFailed))
		xstatsd.PrivateTiming(fmt.Sprintf("backend.service.%s.method.%s.timing", p.serviceName, "HelloWorld"), int64(cost))
		if p.invokeId != "" && logger != nil {
			tokens := []string{
				tm.Now().Format("2006/01/02 15:04:05"),
				"archtech_modelcall_milib",
				p.invokeId,
				p.serviceName,
				"HelloWorld",
				p.myIp,
				xtype_convert.ToString(statMap["ip"]),
				xtype_convert.ToString(callFailed),
				xtype_convert.ToString(callFailed),
				xtype_convert.ToString(cost / 1000),
			}
			logString := strings.Join(tokens, "\t")
			logger.write(logString + "\n")
		}
	}()

	var upstream string
	ctx.StartTime("HelloWorld")
	service, errRet := xconfig.GetService(p.serviceName)
	if errRet != nil {
		ctx.Set("remote", p.serviceName).Warn("get service failed, err:%v", errRet)
		statMap["result"] = 0

		return
	}
	maxRetry := int(service.GetMaxRetry() + 1)
	for i := 0; i < maxRetry; i++ {
		var conn *xpool.XPoolConn
		conn, ip, err2 := p.getConn(p.serviceName)
		upstream += ip + ":"
		if err2 != nil {
			errRet = err2
			ctx.Warn("getconn of [%s] failed, err:%v", p.serviceName, errRet)
			continue
		}

		transport, protocolFactory, errInner := p.getTransportAndProto("HelloWorld", conn, service)
		if errInner != nil {
			errRet = errInner
			ctx.Warn("Get Transport of [%s] failed, err:%v", p.serviceName, errRet)
			conn.Put(false)
			return
		}
		client := NewHelloServiceClientFactory(transport, protocolFactory)
		r, errRet = client.HelloWorld(ctx, name)
		if errRet != nil {
			switch v := errRet.(type) {
			case thrift.TTransportException:
				ctx.Warn("call rpc of [%s] failed, method[%s], transport err:%v", p.serviceName, "HelloWorld", v)
				conn.Put(false)
				continue
			case thrift.TProtocolException:
				ctx.Warn("call rpc of [%s] failed, method[%s], proto err:%v", p.serviceName, "HelloWorld", v)
				conn.Put(false)
				continue
			}
		}
		statMap["retry"] = i
		statMap["result"] = 1
		statMap["upstream"] = upstream
		statMap["ip"] = ip
		conn.Put()
		callFailed = 0
		return
	}
	statMap["retry"] = maxRetry
	statMap["upstream"] = upstream
	statMap["result"] = 0
	statMap["ip"] = "0.0.0.0"
	return
}

type RpcCallHelper struct {
	serviceName   string
	methodTimeout map[string]uint32
	timeout       uint32
	connTimeout   uint32
	rpc           *xrpc.XRpc
	ctx           *thrift.XContext
	balanceKey    string
}

func (p *RpcCallHelper) SetBalanceKey(balanceKey string) {
	p.balanceKey = balanceKey
}

func (p *RpcCallHelper) SetTimeout(connTimeout, readTimeout uint32) {
	if connTimeout <= 0 {
		connTimeout = 1000
	}

	if readTimeout <= 0 {
		readTimeout = 1000
	}
	p.timeout = readTimeout
	p.connTimeout = connTimeout
}

func (p *RpcCallHelper) SetMethodTimeout(method string, timeout uint32) {
	if timeout <= 0 {
		return
	}
	p.methodTimeout[method] = timeout
}

func (p *RpcCallHelper) SetContext(ctx *thrift.XContext) {
	if ctx != nil {
		p.ctx = ctx
	}
}

func (p *RpcCallHelper) SetLogId(logId int64) {
	p.ctx.SetLogId(logId)
}

func (p *RpcCallHelper) SetParentRpcId(rpcId int32) {
	p.ctx.SetParentRpcId(rpcId)
}

func (p *RpcCallHelper) getConn(remoteService string) (conn *xpool.XPoolConn, ip string, err error) {

	conn, ip, err = p.rpc.GetConn(remoteService, p.balanceKey)
	if err != nil {
		p.ctx.Set("remote", p.serviceName).Warn("get conn failed, err:%v", err)
	}
	return
}

func (p *RpcCallHelper) getTransportAndProto(method string,
	conn *xpool.XPoolConn,
	service *xconfig.XService) (transport thrift.TTransport,
	protocolFactory thrift.TProtocolFactory, err error) {

	var transportFactory thrift.TTransportFactory

	timeout := p.timeout
	value, ok := p.methodTimeout[method]
	if ok {
		timeout = value
	}

	if timeout == 0 {
		timeoutStruct := service.GetTimeoutByMethod(method)
		timeout = uint32(timeoutStruct.ReadTimeoutMs)
		if timeoutStruct.ReadTimeoutMs < timeoutStruct.WriteTimeoutMs {
			timeout = uint32(timeoutStruct.WriteTimeoutMs)
		}
	}

	if timeout == 0 {
		timeout = 1000
	}

	transport = thrift.NewTSocketFromConnTimeout(conn, tm.Duration(timeout)*tm.Millisecond)
	transportFactory = thrift.NewTBufferedTransportFactory(8192)
	transportName := service.GetTransport()

	switch transportName {
	case "xm_header":
		transportFactory = thrift.NewXmHeaderTransportFactory(transportFactory)
	case "frame":
		transportFactory = thrift.NewTFramedTransportFactory(transportFactory)
	case "tcp":
	default:
		err = xutil.NewError("unsupported transport:%s", transportName)
		return
	}

	transport = transportFactory.GetTransport(transport)
	protocolName := service.GetProtocol()
	switch protocolName {
	case "binary":
		protocolFactory = thrift.NewTBinaryProtocolFactoryDefault()
	case "compact":
		protocolFactory = thrift.NewTCompactProtocolFactory()
	default:
		err = xutil.NewError("unsupported protocol:%s", protocolName)
		return
	}

	return
}

