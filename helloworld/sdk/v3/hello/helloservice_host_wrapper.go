// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package hello

import (
	"micode.be.xiaomi.com/systech/base/xutil"
	"micode.be.xiaomi.com/systech/soa/thrift"
	"micode.be.xiaomi.com/systech/soa/xrpc/xpool"
	"net"
	tm "time"
)

const (
	HostMaxGetConnRetryTimes = 3
)

var (
	g_pool = xpool.NewPool(xpool.DialTcp, 128, 300)
)

type HelloServiceClientHostWrapper struct {
	RpcCallHostHelper
}

func NewHelloServiceClientHostWrapper(host string, port int, appId string) *HelloServiceClientHostWrapper {
	hostWrapper := &HelloServiceClientHostWrapper{}
	hostWrapper.host = host
	hostWrapper.maxRetry = 0
	hostWrapper.port = port
	hostWrapper.ctx = thrift.NewXContext(appId, 0, 0)
	hostWrapper.methodTimeout = make(map[string]uint32)
	hostWrapper.protocolName = "binary"

	hostWrapper.transportName = "xm_header"

	return hostWrapper
}

// Parameters:
//  - Name
func (p *HelloServiceClientHostWrapper) HelloWorld(name string) (r *Result_, errRet error) {
	statMap := make(map[string]interface{})
	ctx := thrift.NewXContext("callbyhost", p.ctx.GetLogId(), p.ctx.GetRpcId())
	statMap["rpc_id"] = ctx.GetRpcId()
	defer func() {
		p.ctx.Set("HelloWorld", statMap)
	}()

	var upstream string
	ctx.StartTime("HelloWorld")
	maxRetry := int(p.maxRetry + 1)
	for i := 0; i < maxRetry; i++ {
		var conn *xpool.XPoolConn
		conn, ip, err2 := p.getConn()
		upstream += ip + ":"
		if err2 != nil {
			ctx.Warn("getconn failed, err:%v", err2)
			errRet = err2
			continue
		}

		transport, protocolFactory, errInner := p.getTransportAndProto("HelloWorld", conn)
		if errInner != nil {
			errRet = errInner
			ctx.Warn("Get Transport failed, err:%v", errRet)
			conn.Put(false)
			return
		}
		client := NewHelloServiceClientFactory(transport, protocolFactory)
		r, errRet = client.HelloWorld(ctx, name)
		if errRet != nil {
			switch v := errRet.(type) {
			case thrift.TTransportException:
				ctx.Warn("call rpc failed, method[%s], transport err:%v", "HelloWorld", v)
				conn.Put(false)
				continue
			case thrift.TProtocolException:
				ctx.Warn("call rpc failed, method[%s], proto err:%v", "HelloWorld", v)
				conn.Put(false)
				continue
			}
		}

		statMap["retry"] = i
		statMap["result"] = 1
		statMap["upstream"] = upstream
		cost := ctx.EndTime("HelloWorld")
		statMap["cost"] = cost
		conn.Put()
		return
	}
	cost := ctx.EndTime("HelloWorld")
	statMap["cost"] = cost
	statMap["retry"] = maxRetry
	statMap["result"] = 0
	statMap["upstream"] = upstream
	return
}

type RpcCallHostHelper struct {
	host          string
	port          int
	maxRetry      int
	methodTimeout map[string]uint32
	timeout       uint32
	connTimeout   uint32
	ctx           *thrift.XContext
	balanceKey    string

	protocolName  string
	transportName string
}

func (p *RpcCallHostHelper) SetBalanceKey(balanceKey string) {
	p.balanceKey = balanceKey
}

func (p *RpcCallHostHelper) SetTimeout(connTimeout, readTimeout uint32) {
	if connTimeout <= 0 {
		connTimeout = 1000
	}

	if readTimeout <= 0 {
		readTimeout = 1000
	}
	p.timeout = readTimeout
	p.connTimeout = connTimeout
}

func (p *RpcCallHostHelper) SetMethodTimeout(method string, timeout uint32) {
	if timeout <= 0 {
		timeout = 1000
		return
	}
	p.methodTimeout[method] = timeout
}

func (p *RpcCallHostHelper) SetContext(ctx *thrift.XContext) {
	if ctx != nil {
		p.ctx = ctx
	}
}

func (p *RpcCallHostHelper) SetLogId(logId int64) {
	p.ctx.SetLogId(logId)
}

func (p *RpcCallHostHelper) SetParentRpcId(rpcId int32) {
	p.ctx.SetParentRpcId(rpcId)
}

func (p *RpcCallHostHelper) SetProtocol(protocol string) {
	p.protocolName = protocol
}

func (p *RpcCallHostHelper) SetTransport(transport string) {
	p.transportName = transport
}

func (p *RpcCallHostHelper) getConn() (conn *xpool.XPoolConn, ip string, err error) {

	i := 0
	ips, err := net.LookupHost(p.host)
	if err != nil {
		return
	}

	length := len(ips)
	if length == 0 {
		err = xutil.NewError("host:%s not have ips", p.host)
		return
	}

	for i = 0; i < HostMaxGetConnRetryTimes; i++ {
		ip = ips[i%length]
		conn, err = g_pool.Get(ip, p.port, p.connTimeout)
		if err != nil {
			p.ctx.Warn("get conn failed, err:%v", err)
			continue
		}

		break
	}

	return
}

func (p *RpcCallHostHelper) getTransportAndProto(method string,
	conn *xpool.XPoolConn) (transport thrift.TTransport,
	protocolFactory thrift.TProtocolFactory, err error) {

	var transportFactory thrift.TTransportFactory

	timeout := p.timeout
	value, ok := p.methodTimeout[method]
	if ok {
		timeout = value
	}

	if timeout == 0 {
		timeout = 1000
	}

	transport = thrift.NewTSocketFromConnTimeout(conn, tm.Duration(timeout)*tm.Millisecond)
	transportFactory = thrift.NewTBufferedTransportFactory(8192)

	switch p.transportName {
	case "xm_header":
		transportFactory = thrift.NewXmHeaderTransportFactory(transportFactory)
	case "frame":
		transportFactory = thrift.NewTFramedTransportFactory(transportFactory)
	case "tcp":
	default:
		err = xutil.NewError("unsupported transport:%s", p.transportName)
		return
	}

	transport = transportFactory.GetTransport(transport)
	switch p.protocolName {
	case "binary":
		protocolFactory = thrift.NewTBinaryProtocolFactoryDefault()
	case "compact":
		protocolFactory = thrift.NewTCompactProtocolFactory()
	default:
		err = xutil.NewError("unsupported protocol:%s", p.protocolName)
		return
	}

	return
}

